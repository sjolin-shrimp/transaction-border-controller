// ============================================================================
// CoreProver v0.3 Test Harness
// File: tests/harness/types.rs
//
// Purpose:
//   Provide test-harness-level data types that:
//     * Wrap and convert test timestamps into canonical v0.3 types
//     * Support deterministic provenance and session/receipt testing
//     * Bridge between engine String errors and typed harness errors
//     * Define driver API parameters and scenario results
//     * Avoid pulling engine-internal structs into harness code
//
// This module acts as a glue layer between:
//     - TimeController (test simulator)
//     - MockChain (deterministic provenance generator)
//     - EngineDriver (wrapper around engine.rs)
//     - coreprover_types_v03::* (canonical public schemas)
//
// ============================================================================

#![allow(dead_code)]

use serde::{Deserialize, Serialize};
use std::time::Duration;
use coreprover_types_v03::{
    TripleTimestamp, EscrowState, CoreProverReceipt, PaymentProfile,
};

// ============================================================================
// HarnessTimestamp
//
// Internal representation of timestamps in the test harness.
// Wraps the triple-clock values created by TimeController and converts
// to v0.3 canonical TripleTimestamp for engine receipts & views.
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HarnessTimestamp {
    pub mono: u64,
    pub unix: u64,
    pub iso: String,
}

impl HarnessTimestamp {
    pub fn new(mono: u64, unix: u64, iso: String) -> Self {
        Self { mono, unix, iso }
    }

    /// Convert to canonical v0.3 TripleTimestamp
    pub fn into_triple(self) -> TripleTimestamp {
        TripleTimestamp::new(self.mono, self.unix, self.iso)
    }

    /// Borrowing version
    pub fn as_triple(&self) -> TripleTimestamp {
        TripleTimestamp::new(self.mono, self.unix, self.iso.clone())
    }
}

// ============================================================================
// Session identifiers
//
// A "session" in CoreProver v0.3 corresponds to a TGP SessionID or TxIP flow.
// The harness provides deterministic session IDs to make test assertions stable.
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct HarnessSessionId(String);

impl HarnessSessionId {
    pub fn new(prefix: &str, n: u64) -> Self {
        // Format:
        //   sess_<prefix>_<n>
        Self(format!("sess_{}_{}", prefix, n))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }

    pub fn into_string(self) -> String {
        self.0
    }
}

// ============================================================================
// Order identifiers
//
// These are the test harness equivalents of "order IDs" generated by
// CoreProverEngine. The harness uses human-readable identifiers to help
// debug multi-chain tests more easily.
//
// Note: The engine uses [u8; 32] internally. The driver layer converts.
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct HarnessOrderId(String);

impl HarnessOrderId {
    pub fn new(prefix: &str, n: u64) -> Self {
        // Format:
        //   order_<prefix>_<n>
        Self(format!("order_{}_{}", prefix, n))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }

    pub fn into_string(self) -> String {
        self.0
    }

    /// Convert from engine's raw [u8; 32] to harness-friendly ID
    pub fn from_bytes(bytes: [u8; 32]) -> Self {
        Self(hex::encode(bytes))
    }

    /// Convert to engine's [u8; 32] format
    pub fn to_bytes(&self) -> Result<[u8; 32], String> {
        hex::decode(&self.0)
            .map_err(|e| format!("invalid order id hex: {}", e))
            .and_then(|v| {
                if v.len() == 32 {
                    let mut arr = [0u8; 32];
                    arr.copy_from_slice(&v);
                    Ok(arr)
                } else {
                    Err(format!("order id must be 32 bytes, got {}", v.len()))
                }
            })
    }
}

// ============================================================================
// Transaction ID wrapper
//
// The engine expects TXIDs as String. This wrapper provides type safety
// and integration with MockChain's deterministic TXID generation.
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub struct TxId(String);

impl TxId {
    pub fn new(s: String) -> Self {
        Self(s)
    }

    pub fn from_prefix(prefix: &str, n: u64) -> Self {
        Self(format!("0x{}_{:016x}", prefix, n))
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }

    pub fn into_string(self) -> String {
        self.0
    }
}

impl From<String> for TxId {
    fn from(s: String) -> Self {
        Self(s)
    }
}

impl From<TxId> for String {
    fn from(t: TxId) -> String {
        t.0
    }
}

// ============================================================================
// EngineError - Typed error variants
//
// The canonical engine returns Result<T, String>. This enum categorizes
// those string errors into typed variants for better error handling in tests.
//
// The From<String> impl below parses engine error messages into variants.
// ============================================================================

#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum EngineError {
    EscrowNotFound { order_id: String },
    InvalidState {
        expected: Vec<EscrowState>,
        actual: EscrowState,
    },
    DeadlineExpired {
        deadline_type: String,
        deadline: u64,
        current: u64,
    },
    InsufficientBalance {
        account: String,
        required: u64,
        available: u64,
    },
    TxIdRequired { action: String },
    TimedReleaseDisabled,
    ClaimWindowNotExpired { remaining_secs: u64 },
    AcceptanceWindowNotExpired { remaining_secs: u64 },
    InvalidOperation(String),
}

impl std::fmt::Display for EngineError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            EngineError::EscrowNotFound { order_id } => {
                write!(f, "Escrow not found: {}", order_id)
            }
            EngineError::InvalidState { expected, actual } => {
                write!(
                    f,
                    "Invalid state: expected one of {:?}, got {:?}",
                    expected, actual
                )
            }
            EngineError::DeadlineExpired {
                deadline_type,
                deadline,
                current,
            } => {
                write!(f, "{} deadline expired: {} < {}", deadline_type, deadline, current)
            }
            EngineError::InsufficientBalance {
                account,
                required,
                available,
            } => {
                write!(
                    f,
                    "Insufficient balance for {}: required {}, available {}",
                    account, required, available
                )
            }
            EngineError::TxIdRequired { action } => {
                write!(f, "TXID required for action: {}", action)
            }
            EngineError::TimedReleaseDisabled => {
                write!(f, "Timed release is disabled for this escrow")
            }
            EngineError::ClaimWindowNotExpired { remaining_secs } => {
                write!(f, "Claim window not expired: {} secs remaining", remaining_secs)
            }
            EngineError::AcceptanceWindowNotExpired { remaining_secs } => {
                write!(f, "Acceptance window not expired: {} secs remaining", remaining_secs)
            }
            EngineError::InvalidOperation(msg) => {
                write!(f, "Invalid operation: {}", msg)
            }
        }
    }
}

impl std::error::Error for EngineError {}

/// Convert engine's String errors into typed EngineError variants
impl From<String> for EngineError {
    fn from(s: String) -> Self {
        let lower = s.to_lowercase();

        if lower.contains("not found") {
            EngineError::EscrowNotFound { order_id: s }
        } else if lower.contains("invalid") && lower.contains("state") {
            EngineError::InvalidOperation(s)
        } else if lower.contains("deadline") || lower.contains("expired") {
            if lower.contains("acceptance") {
                EngineError::AcceptanceWindowNotExpired { remaining_secs: 0 }
            } else {
                EngineError::DeadlineExpired {
                    deadline_type: "unknown".into(),
                    deadline: 0,
                    current: 0,
                }
            }
        } else if lower.contains("txid") || lower.contains("required") {
            EngineError::TxIdRequired { action: "unknown".into() }
        } else if lower.contains("timed") && lower.contains("release") {
            if lower.contains("disabled") {
                EngineError::TimedReleaseDisabled
            } else {
                EngineError::ClaimWindowNotExpired { remaining_secs: 0 }
            }
        } else if lower.contains("balance") {
            EngineError::InsufficientBalance {
                account: "unknown".into(),
                required: 0,
                available: 0,
            }
        } else if lower.contains("withdraw") && lower.contains("not") {
            EngineError::AcceptanceWindowNotExpired { remaining_secs: 0 }
        } else {
            EngineError::InvalidOperation(s)
        }
    }
}

// ============================================================================
// CommitParams
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommitParams {
    pub buyer: String,
    pub seller: String,
    pub amount: u64,
    pub profile: Option<PaymentProfile>,
}

impl CommitParams {
    pub fn new(buyer: String, seller: String, amount: u64) -> Self {
        Self { buyer, seller, amount, profile: None }
    }

    pub fn with_profile(mut self, profile: PaymentProfile) -> Self {
        self.profile = Some(profile);
        self
    }
}

// ============================================================================
// ScenarioResult
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScenarioResult {
    pub order_id: HarnessOrderId,
    pub final_state: EscrowState,
    pub settlement_amount: u64,
    pub receipt: Option<CoreProverReceipt>,
}

impl ScenarioResult {
    pub fn new(
        order_id: HarnessOrderId,
        final_state: EscrowState,
        settlement_amount: u64,
        receipt: Option<CoreProverReceipt>,
    ) -> Self {
        Self { order_id, final_state, settlement_amount, receipt }
    }
}

// ============================================================================
// ExpectedOutcome
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum ExpectedOutcome {
    Paid,
    Refunded,
    Withdrawn,
}

// ============================================================================
// HarnessAsset
// ============================================================================

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct HarnessAsset(String);

impl HarnessAsset {
    pub fn usdc() -> Self {
        Self("USDC".into())
    }

    pub fn eth() -> Self {
        Self("ETH".into())
    }

    pub fn native(symbol: &str) -> Self {
        Self(symbol.into())
    }

    pub fn as_str(&self) -> &str {
        &self.0
    }
}

// ============================================================================
// HarnessAmount
// ============================================================================

#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
pub struct HarnessAmount(pub u64);

impl HarnessAmount {
    pub fn into_u128(self) -> u128 {
        self.0 as u128
    }
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn timestamp_converts_to_triple() {
        let h = HarnessTimestamp::new(500, 1_700_000_000, "2024-11-14T12:00:00Z".into());
        let t = h.into_triple();
        assert_eq!(t.mono, 500);
        assert_eq!(t.unix, 1_700_000_000);
        assert_eq!(t.iso, "2024-11-14T12:00:00Z");
    }

    #[test]
    fn session_and_order_ids_are_deterministic() {
        let s1 = HarnessSessionId::new("pizza", 1);
        let s2 = HarnessSessionId::new("pizza", 2);
        assert_ne!(s1.as_str(), s2.as_str());

        let o1 = HarnessOrderId::new("pizza", 1);
        let o2 = HarnessOrderId::new("pizza", 2);
        assert_ne!(o1.as_str(), o2.as_str());
    }

    #[test]
    fn order_id_roundtrip() {
        let bytes = [42u8; 32];
        let oid = HarnessOrderId::from_bytes(bytes);
        let back = oid.to_bytes().unwrap();
        assert_eq!(bytes, back);
    }

    #[test]
    fn txid_creation() {
        let tx = TxId::from_prefix("commit", 123);
        assert!(tx.as_str().starts_with("0xcommit_"));
    }

    #[test]
    fn engine_error_parsing() {
        let e1: EngineError = "Escrow not found".to_string().into();
        assert!(matches!(e1, EngineError::EscrowNotFound { .. }));

        let e2: EngineError = "buyer_commit_txid is required".to_string().into();
        assert!(matches!(e2, EngineError::TxIdRequired { .. }));

        let e3: EngineError = "timed_release disabled".to_string().into();
        assert_eq!(e3, EngineError::TimedReleaseDisabled);
    }

    #[test]
    fn commit_params_builder() {
        let params = CommitParams::new("buyer".into(), "seller".into(), 1000);
        assert_eq!(params.amount, 1000);
        assert!(params.profile.is_none());
    }

    #[test]
    fn asset_helpers_work() {
        let u = HarnessAsset::usdc();
        assert_eq!(u.as_str(), "USDC");

        let e = HarnessAsset::native("DAI");
        assert_eq!(e.as_str(), "DAI");
    }

    #[test]
    fn amount_conversion_is_correct() {
        let a = HarnessAmount(42);
        assert_eq!(a.into_u128(), 42u128);
    }
}